#!/usr/bin/env python3
"""
Shairport-Sync Configuration Generator

Reads ../speaker_config.json and generates individual shairport-sync config files
for each AirPlay stream with unique device ID offsets (required for multiple
AirPlay 2 instances to appear as separate devices).
"""

import json
import sys
from pathlib import Path

CONFIG_FILE = Path(__file__).parent.parent / "speaker_config.json"
OUTPUT_DIR = Path("/etc")


def load_config() -> dict:
    """Load speaker configuration from JSON."""
    if not CONFIG_FILE.exists():
        print(f"Error: {CONFIG_FILE} not found.", file=sys.stderr)
        sys.exit(1)

    with open(CONFIG_FILE) as f:
        return json.load(f)


def generate_shairport_config(stream_id: str, stream_config: dict, offset: int) -> str:
    """Generate shairport-sync config content for one AirPlay stream."""
    name = stream_config.get("name", stream_id)
    port = stream_config.get("port", 7000)

    return f'''// Auto-generated shairport-sync config for {name}
// Generated by generate_shairport_configs.py

general = {{
  name = "{name}";
  port = {port};
  airplay_device_id_offset = {offset};
}};
'''


def main():
    print("=" * 50, file=sys.stderr)
    print("SHAIRPORT-SYNC CONFIG GENERATOR", file=sys.stderr)
    print("=" * 50, file=sys.stderr)

    config = load_config()
    snapcast = config.get("snapcast", {})
    streams = snapcast.get("streams", {})

    # Find all airplay streams
    airplay_streams = {
        sid: sconfig for sid, sconfig in streams.items()
        if sconfig.get("type") == "airplay"
    }

    if not airplay_streams:
        print("No AirPlay streams configured!", file=sys.stderr)
        sys.exit(1)

    print(f"\nGenerating configs for {len(airplay_streams)} AirPlay stream(s)...\n", file=sys.stderr)

    generated_files = []
    for offset, (stream_id, stream_config) in enumerate(sorted(airplay_streams.items())):
        # Determine output filename
        # Use config_file from stream config, or generate default name
        config_file = stream_config.get("config_file")
        if config_file:
            output_path = Path(config_file)
        else:
            # Generate filename based on stream_id
            safe_name = stream_id.replace("airplay_", "")
            output_path = OUTPUT_DIR / f"shairport-sync-{safe_name}.conf"

        # Generate config content
        content = generate_shairport_config(stream_id, stream_config, offset)

        # Write to file
        try:
            output_path.write_text(content)
            print(f"  Created: {output_path}", file=sys.stderr)
            generated_files.append({
                "stream_id": stream_id,
                "name": stream_config.get("name", stream_id),
                "port": stream_config.get("port", 7000),
                "offset": offset,
                "config_file": str(output_path)
            })
        except PermissionError:
            print(f"  Error: Permission denied writing {output_path}", file=sys.stderr)
            print(f"         Run with sudo or change OUTPUT_DIR", file=sys.stderr)
            sys.exit(1)

    # Print summary
    print("\n" + "=" * 50, file=sys.stderr)
    print("GENERATED CONFIGS:", file=sys.stderr)
    print("=" * 50, file=sys.stderr)
    for f in generated_files:
        print(f"  {f['name']}:", file=sys.stderr)
        print(f"    Port: {f['port']}", file=sys.stderr)
        print(f"    Device ID Offset: {f['offset']}", file=sys.stderr)
        print(f"    Config: {f['config_file']}", file=sys.stderr)

    print("\n" + "=" * 50, file=sys.stderr)
    print("USAGE:", file=sys.stderr)
    print("  sudo python3 generate_shairport_configs.py", file=sys.stderr)
    print("\n  Then regenerate snapserver config:", file=sys.stderr)
    print("  python3 generate_snapserver_conf.py > /tmp/snapserver.conf", file=sys.stderr)
    print("  sudo cp /tmp/snapserver.conf /etc/snapserver.conf", file=sys.stderr)
    print("  sudo systemctl restart snapserver", file=sys.stderr)
    print("=" * 50, file=sys.stderr)


if __name__ == "__main__":
    main()
